@import "homework.css"

<div style="text-align: center">学号： 姓名：</div>

# 一、有序数组上的二分法应用

## 1-1 V形数列求最值

### 1. 题目

已知由n个整数构成序列的数据分布为先下降再上升, 即一开始数据是严格递减的, 后来数据是严格递增的, 设计尽可能高效算法, 找到序列中的最小值. 

或：已知由n个整数构成序列的数据分布为先上升再下降, 即一开始数据是严格递增的, 后来数据是严格递减的, 设计尽可能高效算法, 找到序列中的最大值. 

### 2. 分析

假定数据是严格递减-严格递增的. 即如下图

```
\         /
 \       /
  \     /
   \   /
    \_/
  A |B| C
```
任意选择一个点 `pos`, 其位置可能有 A, B, C 三种情况. 

如果位于 A, 那么数据会是 `arr[pos - 1] > arr[pos] > arr[pos + 1]`. 所求点位于 `pos` 的左侧. 
如果位于 C, 那么数据会是 `arr[pos - 1] < arr[pos] < arr[pos + 1]`. 所求点位于 `pos` 的右侧. 
而如果 `pos == B`, 那么 `pos` 恰为所求. 

### 3. 数据结构

数组

### 4. 算法设计

进行二分的操作. 开始选择区间为 `left = 0`, `right = n - 1`. 在此区间进行二分得到 `pos = (left + right) / 2`, 然后根据 `arr[pos - 1]`, `arr[pos]`, `arr[pos + 1]` 得到极值点 (target) 的范围, 是在 pos, 还是 pos 的左侧或右侧. 

如果位于左侧, 那么令 `right = pos;`, 即新的选择区间为 `[left, pos)`. 同理如果位于右侧, 那么令 `left = pos;`, 新的选择区间为 `(pos, right]`

二分的思路逐步缩小二分的区域, 直到得到最终结果. 

### 5. 算法实现

```c

```

### 6. 测试结果

#### #1 结果位于中间

**STDIN**

**输入数据**
```plaintext
29
750 636 570 392 291 195 122 120 103 95 87 68 45 39 25 26 28 30 31 33 36 38 39 40 42 43 45 49 52
```

**输出数据**
```plaintext
14
```


#### #2 结果位于中间 - 1

**输入数据**
```plaintext
29
904 815 751 555 385 345 301 246 164 159 124 104 83 81 82 85 89 94 96 105 113 122 128 139 148 154 156 157 171
```

**输出数据**
```plaintext
13
```

#### #3 结果位于中间 + 1

**输入数据**
```plaintext
29
989 744 536 449 318 259 178 146 128 99 61 46 45 37 31 28 29 31 34 37 40 44 47 48 50 54 59 62 68
```

**输出数据**
```plaintext
15
```


#### #4 结果位于左侧

**输入数据**
```plaintext
30
836 574 344 254 183 129 84 76 77 82 89 97 100 104 113 120 123 129 135 136 138 141 155 158 173 184 197 202 215 225
```

**输出数据**
```plaintext
7
```


#### #5 结果位于右侧

**输入数据**
```plaintext
30
994 895 877 811 736 694 665 619 570 559 525 517 505 456 455 448 428 397 391 384 375 358 331 321 331 338 359 393 412 421
```

**输出数据**
```plaintext
23
```


# 二、有关线性链表的应用

## 2-1 同后缀字符串找环

### 1. 题目

实例：假定采用带头结点的单链表保存单词, 当两个单词有相同的后缀时, 则可共享相同的后缀存储空间. 例如, `loading` 和 `being` 的存储映像如下图所示. 

设 `str1` 和 `str2` 分别指向两个单词所在单链表的头结点, 链表结点结构为 (`data`, `next`) , 请设计一个时间上尽可能高效的算法, 找出由 `str1` 和 `str2` 所指的两个链表共同后缀的起始位置(如图中字符 `i` 所在结点的位置 `p`). 要求:

(1)给出算法的基本设计思想. 

(2)根据设计思想, 采用 `C` 或 `C++` 或 `JAVA` 语言描述算法, 关键之处给出注释. 

(3)说明你所设计算法的时间复杂度. 

### 2. 分析

两个具有交叉节点 (共同后缀) 的链表, 找到共同后缀的开始节点. 即考虑到之前的思考题 `算法设计8 - 线性链表交叉问题`, 即为交叉的链表寻找交点. 而如果把结尾与第二个链表头相连, 遍形成了一个由第一个链表开始, 进入环的一个数据结构. 而原来的交叉点, 也是这个环的入口点. 即思考题的的 `算法设计7 - 线性链表环路问题`

### 3. 数据结构

链表. 结构定义如下

```c
typedef struct _node {
    struct _node* next;
    char data;
} node;
```

### 4. 算法设计

**Part 1. 数据构造**

创建链表. 由于不需要随处插入, 仅仅程序开始时将字符串 `char[]` 转换成链表表示, 因此无需单独的插入函数. 一个始终指向结尾的指针 `ptr = head` 然后不断地进行 创建-赋值-移动到下一个节点 的操作即可.

由于需要手动构造环. 因此需要单独将第二个链表重叠部分不是添加, 而是指向第一个链表.

**Part 2. 连接尾节点和第二个节点头部**

在不改变数据的原有结构的情况下, 重新定义新的 "移动到下一个节点" 的操作. 不采用 `ptr = ptr->next` 的方式, 而是先判断是否到达结尾, 如果未到达结尾那么操作相同, 如果已到达结尾那么移动到第二个链表头部. 这样不需要实际的将链表的尾部与第二个链表头部相连. 

**Part 3. 链表判环**

首先定义两个指针 `fast` 和 `slow`, 然后 `fast` 每次往后走 2 个. `slow` 每次往后走 1 个. 如果 `fast` 遇到了 `NULL`, 那么说明是一条链. 而如果 `fast` 与 `slow` 相遇, 则说明链表里面存在环.

如果已知存在环. 在上面的 `fast` 和 `slow` 相遇的基础上, 一个指针回到第一个节点, 然后两个指针同时以速度 1 移动. 再次相遇的地方是环的入口.

**证明**

### 5. 算法实现


### 6. 测试结果

```plaintext
str1 is loading
str2 is being
--------------------    Test if have circle...    --------------------
Begin. fast is l and slow is l
fast=a slow=o
fast=i slow=a
fast=g slow=d
fast=e slow=i
fast=n slow=n
--------------------    Find circle...    --------------------
fast is n. slow returns to link_list1's head: l
fast=g slow=o
fast=b slow=a
fast=e slow=d
fast=i slow=i
the cross node is i
```